# Скрипт создаёт миниатюрный UDP сервер на 514 порту, который принимает сообщения от Микротика,
# добавляет к ним временные метки и сохраняет их в файл, параллельно выводя в консоль.

# 2 МОМЕНТА!
# На некоторых системах, диск C:\ может быть залочен на запись из соображений безопасности,
# поэтому имеет смысл поменять его на диск D:\ или F:\
# 514 на стороне клиента также может быть закрыт, чтобы его открыть - открываем cmd от админа
# и пишем туда вот такую страшную команду:
# netsh advfirewall firewall add rule name="Syslog UDP 514" dir=in action=allow protocol=UDP localport=514
# Но в большинстве случаев, его открывать не надо, всё работает и так...

# Импортируем библиотеку socket, она предоставляет функции для работы с сетевыми соединениями.
# Без него мы не смогли бы создать сетевой сервер.
import socket

# Библиотека datetime нужна для получения текущей даты и времени, чтобы добавлять временные метки к каждому логу.
from datetime import datetime

# Заводим функцию, которая группирует код для приёма syslog сообщений.
def syslog_listener():
    # Определяем путь, куда будет сохраняться файл с логами.
    # r - сырая строка (raw string), чтобы слеши \ не рассматривались как escape-последовательности.
    # Зачем это нужно? Сырая строка гарантирует, что путь к файлу будет именно таким, каким мы его
    # написали, без неожиданных преобразований, без лишних слешей и кавычек.
    # Файл будет сохранён на диск C:\
    log_file_path = r"C:\mikrotik_logs.txt"

    # Создаем UDP сокет для приема syslog сообщений.
    # socket.AF_INET - используем IPv4 адресацию.
    # socket.SOCK_DGRAM - используем протокол UDP вместо TCP.
    # Переменная sock содержит созданный сокет.
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', 514)) # Здесь говорим: "вся сеть / 514 порт - стандартный порт для syslog".

    print(f'Слушаем syslog на порту 514...')
    print(f'Логи сохраняются в: {log_file_path}')

    try:
        while (True):
            # Ожидание и приёмка данных.
            # sock.recvfrom(1024) - ожидание входящих UDP сообщений.
            # 1024 - максимальный размер принимаемого пакета в байтах.
            # data - полученные данные (байты).
            # addr - кортеж (IP-адрес отправителя, порт отправителя).
            data, addr = sock.recvfrom(1024)

            # УНИВЕРСАЛЬНОЕ ДЕКОДИРОВАНИЕ!
            # MikroTik может отправлять логи в разных кодировках, поэтому пробуем несколько вариантов:
            try:
                log_message = data.decode('utf-8')  # Сначала пробуем стандартную UTF-8.
            except UnicodeDecodeError:
                try:
                    log_message = data.decode('cp866')  # Если не получилось, пробуем DOS-кодировку.
                except UnicodeDecodeError:
                    try:
                        log_message = data.decode('windows-1251')  # Пробуем Windows кириллицу.
                    except UnicodeDecodeError:
                        # Если ничего не помогло, заменяем нечитаемые символы специальными.
                        log_message = data.decode('utf-8', errors='replace')

            # Форматирование записи лога.
            # datetime.now() - текущие дата и время.
            # strftime('%Y-%m-%d %H:%M:%S') - форматирование времени в вид "2025-01-15 14:30:25".
            # \n - принудительный переход на следующую строку.
            log_entry = f"{datetime.now().strftime('%Y-%m-%d %H:%M:%S')} - {log_message}\n"

            # Открываем файл на запись!
            # a - режим append, т.е. ДОзапись в конец файла.
            # encoding='utf-8' - принудительно задаём кодировку utf-8.
            # with open - контекстный менеджер, автоматически закрывает файл после использования.
            with open(log_file_path, 'a', encoding='utf-8') as f:

                # Запись строки в файл - добавляет отформатированную запись лога в файл.
                f.write(log_entry)

            # Вывод в консоль. Показываем полученное сообщение и IP-адрес отправлителя.
            # strip() убирает лишние пробелы и символы перевода строки.
            print(f"Получен лог от {addr[0]}: {log_entry.strip()}")

    # Обработка прерываний клавишами - срабатывает когда пользователь нажал Ctrl + C.
    except KeyboardInterrupt:
        print("\nОстановлено!")

    # Блок finally выполняется всегда, в не зависимости от того, была ошибка или нет.
    finally:
        sock.close()  # Закрытие сокета. Высвобождаем сетевой порт и ресурсы системы.

# Точка входа в программу, запуск основного модуля.
if __name__ == "__main__":
    # Вызов основной функции - запуск нашего syslog-парсера.
    syslog_listener()
# Для работы с сетевыми соединениями.
import socket

# Для получения точного текущего даты и времени с точностью до секунды.
from datetime import datetime

# Для работы с файловой системой и путями.
import os

# 1. Заводим функцию для определения пути на рабочий стол пользователя.
def get_desktop_path():
    try:
        # Способ 1: Через переменную окружения USERPROFILE (самый надежный для Windows).
        # Получаем путь к папке пользователя из переменных окружения.
        user_profile = os.environ.get('USERPROFILE')
        if user_profile:

            # Создаём путь к рабочему столу.
            desktop_path = os.path.join(user_profile, 'Desktop')

            # Проверяем, существует ли папка рабочего стола.
            if os.path.exists(desktop_path):
                print(f"✓ Рабочий стол найден через USERPROFILE: {desktop_path}")
                return desktop_path
            else:
                print("⚠ Папка Desktop не найдена в USERPROFILE")

        # Способ 2: Через домашнюю директорию (запасной вариант).
        # Функция, которая преобразует символ ~ в полный путь к домашней директории.
        # В Windows это C:\Users\ИмяПользователя\
        # В Linux/Mac это /home/ИмяПользователя\ или /Users/ИмяПользователя/
        home_dir = os.path.expanduser("~")
        # Функция для безопасного соединения путей.
        # Она автоматически использует правильные разделители для текущей ОС:
        # В Windows \ (обратный слэш)
        # В Linux/Mac / (прямой слэш)
        desktop_path = os.path.join(home_dir, 'Desktop')
        # Проверяем, существует ли указанный путь в файловой системе.
        if os.path.exists(desktop_path):
            print(f"✓ Рабочий стол найден через домашнюю директорию: {desktop_path}")
            return desktop_path # True если папка существует, False если нет.
        else:
            print("⚠ Папка Desktop не найдена в домашней директории")

        # Способ 3: Если Desktop не найден, используем домашнюю директорию
        print(f"✓ Используем домашнюю директорию: {home_dir}")
        return home_dir

    # Перехватываем любую ошибку, которая может произойти в блоке try.
    except Exception as e:
        print(f"✗ Не удалось определить путь к рабочему столу: {e}")
        # Возвращаем текущую директорию как запасной вариант.
        # CWD - это папка, из которой был запущен Python-скрипт.
        current_dir = os.getcwd()
        print(f"✓ Используем текущую директорию: {current_dir}")
        # Возвращает текущую рабочую директорию как результат функции.
        # Это гарантирует, что функция ВСЕГДА вернёт какой-то путь, даже при ошибках.
        return current_dir

# 2. Заводим функцию test_port (открыт порт, или нет).
def test_port():

    try:
        # Создаём сокет UDP.
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        # Пытаемся занять 514 порт на всех сетевых интерфейсах.
        sock.bind(('0.0.0.0', 514))
        print("✓ Порт 514 успешно открыт")
        # Закрываем сокет, освобождаем порт после проверки.
        sock.close()
        return True

    # Перехват ошибки на тему нехватки прав доступа.
    except PermissionError:
        print("✗ Ошибка прав доступа. Запусти от имени администратора!")
        return False

    # Блок перехвата ошибок операционной системы. OSError - общий класс для системных ошибок.
    except OSError as e:
        print(f"✗ Ошибка: {e}")
        return False

# 3. Заводим функцию прослушки syslog-сообщений.
def syslog_listener():

    # Вызываем функцию get_desktop_path(), которая возвращает путь к рабочему столу.
    desktop_path = get_desktop_path()
    # Соединение путей с правильными разделителями. Создаёт полный путь логов на рабочем столе.
    log_file_path = os.path.join(desktop_path, "../mikrotik_logs.txt")

    print(f"\n✓ Файл логов будет создан: {log_file_path}")

    # Создаём UDP сокет для приёма сообщений.
    # socket.AF_INET - использование IPv4 протокола.
    # socket.SOCK_DGRAM - использование UDP (не требующего установления соединения).
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # Привязываем сокет ко всем сетевым интерфейсам на порту 514.
    sock.bind(('0.0.0.0', 514))

    print(f'\nСлушаем syslog на порту 514...')
    print('Для остановки нажмите Ctrl+C\n')

    try:
        while(True):
            # sock.recvfrom(1024) - блокирующий вызов, ожидает данные на порту.
            # 1024 - максимальный размер принимаемого пакета в байтах.
            # data - полученные байты сообщения.
            # addr - кортеж с информацией об отправителе (IP-адрес и порт).
            # Программа "засыпает" на этой строке до получения данных.
            data, addr = sock.recvfrom(1024)

            try:
                # Попытка декодировать байты в строку используя UTF-8.
                log_message = data.decode('utf-8')
            except UnicodeDecodeError:
                try:
                    # Если не получилось, пробуем CP866 (русская DOS-овская кодировка).
                    # Часто используется в старых Микротах.
                    log_message = data.decode('cp866')
                except UnicodeDecodeError:
                    try:
                        # Если CP866 не сработал, пробуем Windows-1251 (русская кириллица Windows).
                        log_message = data.decode('windows-1251')
                    except UnicodeDecodeError:
                        # Если все кодировки не сработали, принудительно декодируем с заменой ошибок
                        # errors='replace' - нечитаемые символы заменяются на (?).
                        # Это гарантирует нам, что программа не упадёт из-за проблем с кодировкой.
                        log_message = data.decode('utf-8', errors='replace')

            # Убираем лишние пробелы, табы и перенос строк с начала и конца сообщения.
            # Очистка сообщения от ненужных символов, одним словом.
            log_message = log_message.strip()

            # datetime.now() - текущие дата и время.
            # strftime('%Y-%m-%d %H:%M:%S') - вывод в вид типа 2025-01-15 14:30:15
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            # Создание форматированной строки лога.
            # Включает временную метку и сообщение + \n - переход на следующую строку.
            log_entry = f"{timestamp} - {log_message}\n"

            try:
                # with open - контекстный менеджер для автоматического закрытия файла после работы с ним.
                # a - режим append (добавление данных в конец файла, т.е. ДОзапись).
                # encoding='utf-8' - принудительная запись в UTF-8.
                # f.write(log_entry) - запись форматированной строки в файл.
                # Файл автоматически закрывается после выхода из блока with.
                with open(log_file_path, 'a', encoding='utf-8') as f:
                    f.write(log_entry)

            # Обработка ошибок прав доступа к файлу.
            except PermissionError:
                print(f"✗ Ошибка записи в файл {log_file_path}. Проверьте права доступа.")
                return # Аварийное завершение функции.

            # Перехват любых других ошибок при записи файла с логом.
            except Exception as e:
                print(f"✗ Ошибка при записи в файл: {e}")
                return # Аварийное завершение функции.

            # Вывод лога в консоль в реальном времени.
            # addr[0] - это IP-адрес отправителя (первый элемент кортежа addr)
            # Пользователь видит поступающие сообщения.
            print(f"[{timestamp}] От {addr[0]}: {log_message}")

    # Обработка прерывания по Ctrl + C.
    except KeyboardInterrupt:
        print("\n✓ Остановлено пользователем!")
        print(f"✓ Логи сохранены в: {log_file_path}")

    # Блок finally выполняется всегда, независимо от того, как завершилась функция.
    # sock.close() - освобождение сетевого порта и системных ресурсов.
    # Критически важно для предотвращения утечек ресурсов.
    finally:
        sock.close()

# 4. Основная функция, управляющая workflow.
def main():
    print("=== Syslog Listener для MikroTik ===")
    print("Проверка доступности порта 514...")

    # Сперва вызываем функцию test_port(), которая проверяет возможность открытия 514 порта.
    # Функция возвращает true - если порт успешно открыт,
    # или False - если возникли ошибки (нет прав, порт занят и т.д.)
    if test_port():
        print("\nЗапуск syslog listener...")
        # Вызов функции syslog_listener() - запуск бесконечного цикла приёма сообщений.
        # Программа "зависает" здесь до принудительного завершения пользователем (Ctrl + C).
        syslog_listener()

    # Эта часть выполняется если test_port() вернул False.
    # Чёткое сообщение о неудаче запуска.
    else:
        print("\nНе удалось запустить syslog listener.")
        print("Убедитесь, что:")
        print("1. Скрипт запущен от имени администратора")
        print("2. Порт 514 не занят другим приложением")
        print("3. Брандмауэр разрешает входящие подключения на порт 514")

        # Конкретная команда для решения проблемы с брандмауэром Windows.
        # netsh - утилита настройки сети в Windows.
        # advfirewall firewall add rule - добавление правила в расширенный брандмауэр.
        # name="Syslog UDP 514" - понятное имя правила.
        # dir=in - правила для входящего трафика.
        # action=allow - разрешить соединения.
        # protocol=UDP - тип протокола UDP.
        # localport=514 - номер порта 514 (для логов Микротика).
        print("\nДля открытия порта в брандмауэре выполните в cmd от администратора:")
        print(
            'netsh advfirewall firewall add rule name="Syslog UDP 514" dir=in action=allow protocol=UDP localport=514')

# Точка входа в программу, запуск основного модуля.
if __name__ == "__main__":
    main()
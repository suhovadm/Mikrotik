# 3. ПАРСИНГ И СЕЙВИНГ SYSLOG-СООБЩЕНИЙ. ОСНОВНОЙ ФУНКЦИОНАЛ, ПО СУТИ...

# Для работы с сетевыми соединениями.
import socket
# Для получения точных даты и времени с точностью до секунды.
from datetime import datetime
# Для работы с файловой системой и путями.
import os

# Импортируем функцию для определения пути к рабочему столу.
from get_desktop_path import get_desktop_path

# 3. Заводим функцию прослушки syslog-сообщений.
def syslog_listener():
    # Вызываем функцию get_desktop_path(), которая возвращает путь к рабочему столу.
    desktop_path = get_desktop_path()
    # Соединение путей с правильными разделителями. Создаёт полный путь логов на рабочем столе.
    log_file_path = os.path.join(desktop_path, "mikrotik_logs.txt")

    print(f"\n[V] Файл логов будет создан: {log_file_path}")

    # Создаём UDP сокет для приёма сообщений.
    # socket.AF_INET - использование IPv4 протокола.
    # socket.SOCK_DGRAM - использование UDP (не требующего установления соединения).
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    # Привязываем сокет ко всем сетевым интерфейсам на порту 514.
    sock.bind(('0.0.0.0', 514))

    # ★★★ ДОБАВЛЯЕМ ТАЙМАУТ В 1 СЕКУНДУ ДЛЯ МГНОВЕННОЙ РЕАКЦИИ НА CTRL + C ★★★
    sock.settimeout(1.0)

    print(f'\nСлушаем syslog на 514 порту...')
    print('Для остановки нажмите Ctrl + C.')
    print('Программа будет закрыта в течение 1 секунды.\n')

    try:
        while (True):
            try:
                # sock.recvfrom(1024) - блокирующий вызов, ожидает данные на порту.
                # 1024 - максимальный размер принимаемого пакета в байтах.
                # data - полученные байты сообщения.
                # addr - кортеж с информацией об отправителе (IP-адрес и порт).
                # Программа "засыпает" на этой строке до получения данных.
                data, addr = sock.recvfrom(1024)

                try:
                    # Попытка декодировать байты в строку используя UTF-8.
                    log_message = data.decode('utf-8')
                except UnicodeDecodeError:
                    try:
                        # Если не получилось, пробуем CP866 (русская DOS-овская кодировка).
                        # Часто используется в старых Микротах.
                        log_message = data.decode('cp866')
                    except UnicodeDecodeError:
                        try:
                            # Если CP866 не сработал, пробуем Windows-1251 (русская кириллица Windows).
                            log_message = data.decode('windows-1251')
                        except UnicodeDecodeError:
                            # Если все кодировки не сработали, принудительно декодируем с заменой ошибок
                            # errors='replace' - нечитаемые символы заменяются на (?).
                            # Это гарантирует нам, что программа не упадёт из-за проблем с кодировкой.
                            log_message = data.decode('utf-8', errors='replace')

                # Убираем лишние пробелы, табы и перенос строк с начала и конца сообщения.
                # Очистка сообщения от ненужных символов, одним словом.
                log_message = log_message.strip()

                # datetime.now() - текущие дата и время.
                # strftime('%Y-%m-%d %H:%M:%S') - вывод в вид типа 2025-01-15 14:30:15
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                # Создание форматированной строки лога.
                # Включает временную метку и сообщение + \n - переход на следующую строку.
                log_entry = f"{timestamp} - {log_message}\n"

                try:
                    # with open - контекстный менеджер для автоматического закрытия файла после работы с ним.
                    # a - режим append (добавление данных в конец файла, т.е. ДОзапись).
                    # encoding='utf-8' - принудительная запись в UTF-8.
                    # f.write(log_entry) - запись форматированной строки в файл.
                    # Файл автоматически закрывается после выхода из блока with.
                    with open(log_file_path, 'a', encoding='utf-8') as f:
                        f.write(log_entry)

                # Обработка ошибок прав доступа к файлу.
                except PermissionError:
                    print(f"[x] Ошибка записи в файл {log_file_path}. Проверьте права доступа.")
                    return  # Аварийное завершение функции.

                # Перехват любых других ошибок при записи файла с логом.
                except Exception as e:
                    print(f"[x] Ошибка при записи в файл: {e}")
                    return  # Аварийное завершение функции.

                # Вывод лога в консоль в реальном времени.
                # addr[0] - это IP-адрес отправителя (первый элемент кортежа addr)
                # Пользователь видит поступающие сообщения.
                print(f"[{timestamp}] От {addr[0]}: {log_message}")

            # ★★★ ОБРАБАТЫВАЕМ ТАЙМАУТ - ПРОСТО ПРОДОЛЖАЕМ ЦИКЛ ★★★
            except socket.timeout:
                continue

    # Обработка прерывания по Ctrl + C.
    except KeyboardInterrupt:
        print("\n[V] Остановлено пользователем!")
        print(f"[V] Логи сохранены в: {log_file_path}")

    # Блок finally выполняется всегда, независимо от того, как завершилась функция.
    # sock.close() - освобождение сетевого порта и системных ресурсов.
    # Критически важно для предотвращения утечек ресурсов.
    finally:
        sock.close()